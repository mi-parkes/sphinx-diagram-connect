import os
import sys
import sphinx
from sphinx.errors import NoUri
from docutils import nodes
import glob
import re
import xml.etree.ElementTree as ET
from lxml import etree
from sphinx.events import EventListener
from sphinx_needs.needsfile import NeedsList

# Get the Sphinx logger for informative messages
logger = sphinx.util.logging.getLogger(__name__)

__version__ = "1.0.0"
version_info = (1, 0, 0)

# Define the public API of the package. Only names in __all__ will be imported
# when a user does 'from sphinx_diagram_connect import *'.
__all__ = ["setup", "DiagramConnect"]


class DiagramConnect:
    """
    A class to handle the resolution of Sphinx references within SVG files
    generated by Sphinx, particularly for connecting diagrams to
    other documentation elements like reST references or sphinx-needs.
    """

    def __init__(self, app):
        """
        Initializes the DiagramConnect class with the Sphinx application object.

        :param app: The Sphinx application object.
        :type app: sphinx.application.Sphinx
        """
        self.app = app  # Store the app object for later use by methods that don't receive it directly
        self.sphinx_diagram_connect_verbose = getattr(
            app.config, "sphinx_diagram_connect_verbose", False
        )
        self.needs_build_json = getattr(app.config, "needs_build_json", False)
        self.needs_list = None

    def _init_needs(self):
        """
        Initializes and loads the needs list from the sphinx-needs JSON output.

        This function attempts to load the `needs.json` file generated by the
        sphinx-needs extension. If successful, it extracts the needs for the
        first version found in the JSON data.

        This is an internal helper method.

        :returns: A dictionary of needs if `needs.json` is found and parsed,
                  otherwise None.
        :rtype: dict or None
        """
        # Use self.app as the app object is stored during initialization
        needs_list_obj = NeedsList(
            self.app.env.config, self.app.outdir, self.app.srcdir
        )
        needs_list_obj.load_json(os.path.join(self.app.builder.outdir, "needs.json"))
        ret = None
        if needs_list_obj and needs_list_obj.needs_list:
            if "versions" in needs_list_obj.needs_list:
                keys = list(needs_list_obj.needs_list["versions"].keys())
                if keys:
                    version = keys[0]
                    if "needs" in needs_list_obj.needs_list["versions"][version]:
                        ret = needs_list_obj.needs_list["versions"][version]["needs"]
        return ret

    def _resolve_ref(self, target, rtype):
        """
        Resolves a Sphinx reference (e.g., ``:ref:`target```, ``:doc:`target```) to its URI.

        This method uses Sphinx's internal mechanism to resolve a given reference
        target to its corresponding URI within the build.

        This is an internal helper method.

        :param target: The target name of the reference (e.g., 'my-section', 'my-document').
        :type target: str
        :returns: The resolved URI (path to the HTML page with anchor), or None if
                  the reference cannot be resolved.
        :rtype: str or None
        :raises sphinx.errors.NoUri: If the reference domain or type is not found.
        """

        if ':' not in rtype:
            refdomain = "std"  # Standard Sphinx domain for 'ref' and 'doc' types
            typ = "ref"  # The type of reference being resolved (can be 'doc' or 'ref')
            node = nodes.literal_block("dummy", "dummy")
            node["refexplicit"] = False
            contnode = None
            rtarget = target.lower()

        else:
            logger.info(
                "href resolution of domain: '%s'"
                % (rtype),
                color="purple",
            )
            refdomain,typ = rtype.split(':')
            node = nodes.literal_block("dummy", "dummy")
            contnode = nodes.literal(target, target)
            node["refexplicit"] = False
            rtarget = target
            
        # refdoc is a dummy document name needed for resolve_xref, as per Sphinx API
        # Use self.app as the app object is stored during initialization
        refdoc = self.app.builder.imagedir + "/dummy.svg"
        try:
            try:
                # Use self.app as the app object is stored during initialization
                domain = self.app.env.domains[refdomain]
            except KeyError as exc:
                raise NoUri(target, typ) from exc
            # Resolve the cross-reference
            # Use self.app as the app object is stored during initialization
            newnode = domain.resolve_xref(
                self.app.env, refdoc, self.app.builder, typ, rtarget, node, contnode
            )
            if newnode:
                return newnode.attributes["refuri"]
            else:
                return None
        except NoUri:
            return None

    def resolve_references(self, app_from_event, exception):
        """
        Resolves Sphinx references embedded within SVG files generated by Sphinx.

        This method iterates through all SVG files in the Sphinx build output's
        image directory. It looks for specific patterns (e.g., ``:ref:`target``` or
        ``:doc:`target```) in `href` attributes within the SVG XML. If a pattern is found,
        it attempts to resolve the reference to an actual URI using `_resolve_ref`
        or by looking up sphinx-needs data. The SVG file is then updated with
        the resolved URIs.

        This is the main method connected to Sphinx's 'build-finished' event.

        :param app_from_event: The Sphinx application object passed by the event.
        :type app_from_event: sphinx.application.Sphinx
        :param exception: The exception object if an error occurred during the build, otherwise None.
        :type exception: Exception or None
        """
        # It's safer to use the 'app' object passed directly by the event handler for consistency.
        # Although self.app is available, using app_from_event explicitly ensures the correct context.
        app = app_from_event

        if app.builder.format == "html":
            # Access config values and needs list using the app object from the event
            # or the already stored self.sphinx_diagram_connect_verbose and self.needs_build_json
            if self.needs_build_json and self.needs_list is None:
                self.needs_list = self._init_needs()  # _init_needs uses self.app

            # Regex pattern to find Sphinx references in the format :ref:`target` or :doc:`target`
            pattern = r"(:([a-z:]+):`([^`]+)`)"
            href = ""

            # Iterate over all SVG files in the image directory
            # Use app.builder.outdir and app.builder.imagedir from the event's app object
            for filename in glob.glob(
                os.path.join(app.builder.outdir, app.builder.imagedir) + "/*.svg",
                recursive=True,
            ):
                # Read the SVG file content as binary
                with open(filename, "rb") as file:
                    svg_content = file.read()

                # Parse the SVG content using lxml for robust XML parsing
                parser = etree.XMLParser(ns_clean=True)
                root = etree.fromstring(svg_content, parser)

                modified = False
                # Iterate through all elements in the SVG tree
                for element in root.iter():
                    keys = list(element.attrib.keys())
                    if len(keys) > 0:
                        # Check if any attribute key ends with 'href' (e.g., {http://www.w3.org/1999/xlink}href)
                        # The lxml parser might return namespace-prefixed keys, so we check endswith
                        for key in keys:
                            if key.endswith("href"):
                                href = key
                                break  # Found the href attribute, break from inner loop
                        else:  # If no href attribute found, continue to next element
                            continue

                        # Check if the href attribute's value matches the Sphinx reference pattern
                        match = re.search(pattern, element.attrib[href])
                        if match:
                            resolved = False
                            # Extract the full match, type (ref/doc), and the target (old_href)
                            complete, type, old_href = match.groups()

                            # Attempt to resolve using the internal _resolve_ref method
                            new_href = self._resolve_ref(
                                old_href, type
                            )  # _resolve_ref uses self.app
                            if new_href:
                                element.attrib[href] = new_href
                                if (
                                    self.sphinx_diagram_connect_verbose
                                ):  # Using stored config value
                                    logger.info(
                                        "href resolution: '%s' -> '%s'"
                                        % (old_href, new_href),
                                        color="purple",
                                    )
                                resolved = True
                            elif self.needs_list:  # Using stored needs_list
                                # If Sphinx resolver fails, try to resolve using sphinx-needs data
                                if old_href in self.needs_list:
                                    # Construct the path to the needs document.
                                    # TODO: This relative path needs to be robustly handled based on build paths.
                                    element.attrib[href] = (
                                        f"../{self.needs_list[old_href]['docname']}.html#{old_href}"
                                    )
                                    resolved = True
                            if resolved:
                                modified = True
                            else:
                                # Log a warning if the reference could not be resolved
                                logger.warning(
                                    "Failed to resolve reference:'%s' in file:'%s'"
                                    % (old_href, filename[len(os.getcwd()) + 1 :]),
                                    color="darkred",
                                    type="sphinx-diagram-connect-missing-reference",
                                )

                if modified:
                    logger.info(
                        "Updating SVG file with resolved references:'%s'"
                        % filename[len(os.getcwd()) + 1 :],
                        color="darkblue",
                    )
                    try:
                        # Write the modified SVG content back to the file
                        with open(filename, "wb") as file:
                            # Use pretty_print for readability and include XML declaration for valid SVG
                            file.write(
                                etree.tostring(
                                    root,
                                    pretty_print=True,
                                    xml_declaration=True,
                                    encoding="UTF-8",
                                )
                            )
                    except Exception as exc:
                        logger.error(
                            "Failed to write file:'%s' - %s"
                            % (filename[len(os.getcwd()) + 1 :], exc)
                        )
        return


def setup(app):
    """
    Sets up the Sphinx extension.

    This function instantiates the `DiagramConnect` class and registers its
    `resolve_references` method to be called after the Sphinx build is finished.
    It also adds a configuration value 'sphinx_diagram_connect_verbose' which
    can be set in conf.py to enable verbose logging.

    :param app: The Sphinx application object.
    :type app: sphinx.application.Sphinx
    :returns: A dictionary containing Sphinx extension metadata.
    :rtype: dict
    """
    # Instantiate the DiagramConnect class
    diagram_connect_instance = DiagramConnect(app)

    # Connect the resolve_references method of the instance to the 'build-finished' event
    # The method needs to accept both 'app' and 'exception' arguments from the event.
    app.connect("build-finished", diagram_connect_instance.resolve_references)

    # Add a configuration value that can be set in conf.py
    # 'sphinx_diagram_connect_verbose': default value False, applies to 'html' builder.
    app.add_config_value("sphinx_diagram_connect_verbose", False, "html")

    # Return metadata about the extension
    return {
        "parallel_read_safe": True,
        "parallel_write_safe": True,
        "version": __version__,
    }